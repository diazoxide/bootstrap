Index: bs.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\nimport shlex\nimport subprocess\nimport sys\nimport jsonpickle\n\n\nclass Bootstrap:\n    name: str\n    root_directory: str = '~/bs-project'\n    modules: list = []\n    env: str = 'dev'\n    external_modules: list = []\n    variables: dict = {}\n\n    __modules_directory: str = os.path.abspath('modules')\n    __src_dir: str = os.path.dirname(os.path.abspath(__file__))\n    __external_modules_directory: str = __src_dir + '/modules'\n\n    class Module:\n        name: str\n        root_directory_name: str | None = None\n        docker_compose_file: str = 'dockercompose.yml'\n        external: bool = False\n        commands: list = []\n        variables: dict = {}\n\n        class Command:\n            on: str = 'up'\n            condition: str | list = []\n            module: str | None = None\n            container: str\n            command: str | list\n\n    def prepare(self):\n        for external_module in self.external_modules:\n            module_dir = self.get_module_dir(external_module, external=True)\n            with open(module_dir + '/bs-module.json', 'r') as module_json_file:\n                module_json = module_json_file.read()\n            module = jsonpickle.decode(module_json)\n            self.modules.insert(\n                0,\n                module\n            )\n\n    def add_module(self, module: Module):\n        self.modules.append(module)\n        module.bootstrap = self\n        return self\n\n    def get_module_root_dir(self, module: Module | str):\n        module = self.get_module(module)\n        return self.root_directory + '/' + self.env + '/' + (module.root_directory_name or module.name)\n\n    def get_module_dir(self, module: Module | str, external: bool = False):\n        module_name = module.name if isinstance(module, Bootstrap.Module) else module\n        if external or isinstance(module, Bootstrap.Module) and module.external:\n            return self.__external_modules_directory + '/' + module_name\n        return self.__modules_directory + '/' + module_name\n\n    def get_module_env(self, module: Module | str):\n        module = self.get_module(module)\n\n        env = os.environ.copy()\n        env['root_dir'] = self.get_module_root_dir(module)\n        try:\n            bootstrap_variables = self.variables[self.env]\n        except KeyError:\n            bootstrap_variables = {}\n\n        try:\n            module_variables = module.variables[self.env]\n        except KeyError:\n            module_variables = {}\n\n        env.update(bootstrap_variables)\n        env.update(module_variables)\n\n        return env\n\n    def get_stack_name(self, module: Module):\n        return '{0}-{1}-{2}'.format(self.name, self.env, module.name)\n\n    def up_module(self, module: Module | str, rebuild: bool, remote: bool):\n        print(self.get_module_dir(module))\n        os.chdir(self.get_module_dir(module))\n        command = [\n            'docker-compose',\n            '-p',\n            self.get_stack_name(module),\n            # '--env-file=./env/' + self.env + '.env',\n            'up', '-d', '--force-recreate'\n        ]\n\n        if rebuild:\n            command.append('--build')\n\n        res = subprocess.run(command, env=self.get_module_env(module))\n\n        if res.returncode == 0:\n            self.exec_module_commands(module, 'up', remote)\n\n    def get_module(self, module: str | Module):\n        if isinstance(module, Bootstrap.Module):\n            return module\n\n        for _module in self.modules:\n            if _module.name == module:\n                return _module\n\n        raise Exception('Module ' + module + ' not found.')\n\n    def exec_module_commands(self, module: Module | str, on: str, remote: bool):\n        module = self.get_module(module)\n\n        for command in module.commands:\n            if command.on == on:\n                self.exec_module_command(module, command, remote)\n\n    def exec_module_command(self, module: Module | str, command: Module.Command, remote: bool):\n\n        module = self.get_module(module)\n\n        command_list = [command.command] if isinstance(command.command, str) else command.command\n\n        for single_command in command_list:\n            must_exec = False\n            condition = [command.condition] if isinstance(command.condition, str) else command.condition\n\n            if not condition:\n                must_exec = True\n            else:\n                if remote and \"remote\" in condition:\n                    must_exec = True\n                if not remote and \"not:remote\" in condition:\n                    must_exec = True\n\n            if must_exec:\n                self.exec(command.module or module, command.container, single_command)\n\n        self.exec_module_commands(module, 'after-command-exec', remote)\n\n    def up(self, rebuild: bool | str = False, remote: bool | str = False):\n        rebuild = True if rebuild == 'true' or rebuild == True else False\n        remote = True if remote == 'true' or remote == True else False\n        for module in self.modules:\n            self.up_module(module, rebuild, remote)\n\n    def get_container_name(self, module: Module, container: str):\n        return self.name + '-' + self.env + '-' + module.name + '-' + container + '-1'\n\n    def exec(self, module: Module | str, container: str, command: str):\n\n        module = self.get_module(module)\n        os.chdir(self.get_module_dir(module))\n\n        variables = self.get_module_env(module)\n        _command_str = ('docker compose -p' + self.get_stack_name(module) + ' exec ' + container + ' ' + command) \\\n            .format(**self.get_module_env(module))\n        _command = shlex.split(_command_str)\n\n        return subprocess.run(_command, env=variables)\n\n\n# bs = Bootstrap('xcontain','local', modules=[\n#     Bootstrap.Module('monolith'),\n# ])\n# json_data = jsonpickle.encode(bs)\n# print(json_data)\n# exit(0)\n\nwith open('./bs.json', 'r') as file:\n    json_data = file.read()\n\nbs = jsonpickle.decode(json_data)\nbs.prepare()\nmethod = sys.argv[1]\nargs_obj = {}\n\nfor arg in sys.argv[2:]:\n    if '=' in arg:\n        sep = arg.find('=')\n        key, value = arg[:sep], arg[sep + 1:]\n        args_obj[key] = value\n\ngetattr(bs, method)(**args_obj)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/bs.py b/bs.py
--- a/bs.py	(revision fbaa17ce14c7b5486c6f1f4c93a38549310684dc)
+++ b/bs.py	(date 1652169101596)
@@ -161,6 +161,33 @@
 
         return subprocess.run(_command, env=variables)
 
+    @staticmethod
+    def init_from_json(json_name: str = 'bs.json'):
+        with open('./bs.json', 'r') as json_file:
+            data = file.read()
+        bs = jsonpickle.decode(data)
+        if isinstance(bs, Bootstrap):
+            bs.prepare()
+            return bs
+
+        raise Exception('Bootstrap json file')
+
+
+    @staticmethod
+    def setup():
+        if os.path.isfile('./bs.json'):
+            raise Exception('Bootstrap already inited.')
+        bs = Bootstrap()
+        bs.name = input("Name of bootstrap: ")
+        bs.modules = []
+        bs.external_modules = []
+
+        json_data = jsonpickle.encode(bs, indent=4)
+
+        f = open("./bs.json", "w")
+        f.write(json_data)
+        f.close()
+
 
 # bs = Bootstrap('xcontain','local', modules=[
 #     Bootstrap.Module('monolith'),
@@ -169,11 +196,14 @@
 # print(json_data)
 # exit(0)
 
-with open('./bs.json', 'r') as file:
-    json_data = file.read()
-
-bs = jsonpickle.decode(json_data)
-bs.prepare()
+try:
+    with open('./bs.json', 'r') as file:
+        json_data = file.read()
+    bs = jsonpickle.decode(json_data)
+    bs.prepare()
+except FileNotFoundError:
+    bs = Bootstrap()
+
 method = sys.argv[1]
 args_obj = {}
 
Index: requirements.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>jsonpickle
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/requirements.txt b/requirements.txt
--- a/requirements.txt	(revision fbaa17ce14c7b5486c6f1f4c93a38549310684dc)
+++ b/requirements.txt	(date 1652169101599)
@@ -1,1 +1,1 @@
-jsonpickle
\ No newline at end of file
+jsonpickle==2.1.0
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
--- /dev/null	(date 1652168740453)
+++ b/.idea/misc.xml	(date 1652168740453)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" project-jdk-name="Python 3.10" project-jdk-type="Python SDK" />
+  <component name="SwUserDefinedSpecifications">
+    <option name="specTypeByUrl">
+      <map />
+    </option>
+  </component>
+</project>
\ No newline at end of file
